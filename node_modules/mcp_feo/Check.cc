#include <node.h>
#include "Check.h"

using namespace v8;

Persistent<Function> Check::constructor;

Check::Check()
{
    this->gl = NULL;
    this->pDrawNumType = NULL;
}

Check::~Check()
{
    if(this->pDrawNumType != NULL)
    {
        delete this->pDrawNumType;
    }
    if(this->gl != NULL)
    {
        delete this->gl;
    }
}

void Check::Init()
{
    Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
    tpl->SetClassName(String::NewSymbol("Check"));
    tpl->InstanceTemplate()->SetInternalFieldCount(1);
    tpl->PrototypeTemplate()->Set(String::NewSymbol("setDrawNum"), FunctionTemplate::New(SetDrawNum)->GetFunction());
    tpl->PrototypeTemplate()->Set(String::NewSymbol("setGl"), FunctionTemplate::New(SetGl)->GetFunction());
    tpl->PrototypeTemplate()->Set(String::NewSymbol("count"), FunctionTemplate::New(Count)->GetFunction());
    tpl->PrototypeTemplate()->Set(String::NewSymbol("count0100"), FunctionTemplate::New(Count0100)->GetFunction());
    tpl->PrototypeTemplate()->Set(String::NewSymbol("count0101"), FunctionTemplate::New(Count0101)->GetFunction());
    tpl->PrototypeTemplate()->Set(String::NewSymbol("count0102"), FunctionTemplate::New(Count0102)->GetFunction());
    constructor = Persistent<Function>::New(tpl->GetFunction());
}

/**
 * 真正初始化的方法
 */
Handle<Value> Check::New(const Arguments& args)
{
    HandleScope scope;
    if(args.IsConstructCall()){ //from new GradeLevel()
        Check * obj = new Check();
        obj->Wrap(args.This());
        return args.This();
    }
    else{   //from GradeLevel()
        const int argc = 0;
        Local<Value> argv[argc] = {};
        return scope.Close(constructor->NewInstance(argc, argv));
    }
}

/**
 * 设置红球开奖号码
 */
Handle<Value> Check::SetDrawNum(const Arguments& args)
{
    HandleScope scope;
    //校验参数的类型
    if (!args[0]->IsString()) {
        ThrowException(Exception::TypeError(String::New("Wrong arguments")));
        return scope.Close(Undefined());
    }
    Check *obj = ObjectWrap::Unwrap<Check>(args.This());

    Handle<String> pStr = args[0]->ToString();
    int length = pStr->Utf8Length();
    char *pChar = new char[length];
    pStr->WriteUtf8(pChar);
    //设置开奖号码的类型信息
    obj->pDrawNumType = new NumType(pChar, length);
    delete[] pChar;
    return scope.Close(Undefined());
}

/**
 * 设置奖级信息
 */
Handle<Value> Check::SetGl(const Arguments& args)
{
    HandleScope scope;
    Check *obj = ObjectWrap::Unwrap<Check>(args.This());
    GradeLevel *gl = ObjectWrap::Unwrap<GradeLevel>(args[0]->ToObject());
    int lCount = gl->getLevelCount();
    GradeLevel *newGl = new GradeLevel(lCount);
    for(int i = 0; i < lCount; i++)
    {
        newGl->setBonus(i, gl->getBonus(i));
    }
    obj->gl = newGl;
    return scope.Close(Undefined());
}

/**
 * 算奖
 */
Handle<Value> Check::Count(const Arguments& args)
{
    HandleScope scope;
    Handle<Array> array = Array::New();
    Handle<Object> obj = Object::New();
    obj->Set(String::NewSymbol("bonus"), Number::New(4000));
    obj->Set(String::NewSymbol("bonusBeforeTax"), Number::New(4000));
    obj->Set(String::NewSymbol("level"), Number::New(1));
    obj->Set(String::NewSymbol("count"), Number::New(1));
    array->Set(0, obj);


    return scope.Close(array);
}

/**
 * 组24，单式算计
 */
Handle<Value> Check::Count0100(const Arguments& args)
{
    HandleScope scope;
    Check *self = ObjectWrap::Unwrap<Check>(args.This());
    Handle<Object> rst = Object::New();
    Handle<Array> array = Array::New();
    long bonus = 0;
    long bonusBeforeTax = 0;
    //号码类型是否相同
    if(self->pDrawNumType->getType() == NUM_TYPE_Z24)
    {
        //获得号码的字符串
        Local<Object> pObj = Local<Object>::Cast(args[0]);
        Local<String> pNum = pObj->Get(String::NewSymbol("number"))->ToString();
        int length = pNum->Utf8Length();
        char *pChar = new char[length];
        pNum->WriteUtf8(pChar);

        int jCount = 0;
        char *tmp = pChar;
        for(int j = 0; j < length; j++)
        {
            char jChar = pChar[j];
            if(jChar == ';' || j == length - 1) //号码结束
            {
                if(j == length - 1 && jChar != ';') //如果到了号码末尾，需要把最后一个字符加进来
                {
                    jCount++;
                }
                NumType *pNumType = new NumType(tmp, jCount);
                bool hit = true;
                int drawLen = self->pDrawNumType->getCharLen();
                for(int i = 0; i < drawLen; i++)
                {
                    char c = self->pDrawNumType->getCharAt(i);
                    int iCount = self->pDrawNumType->getCharCountAt(i);
                    if(pNumType->getCharCount(c) != iCount)
                    {
                        hit = false;
                        break;
                    }
                }
                if(hit)
                {
                    long curBonus = self->gl->getBonus(0);
                    long curBonusBeforeTax = self->gl->getBonus(0);
                    Handle<Object> obj = Object::New();
                    obj->Set(String::NewSymbol("bonus"), Number::New(curBonus));
                    obj->Set(String::NewSymbol("bonusBeforeTax"), Number::New(curBonusBeforeTax));
                    obj->Set(String::NewSymbol("level"), Number::New(1));
                    obj->Set(String::NewSymbol("count"), Number::New(1));
                    array->Set(array->Length(), obj);
                    bonus += curBonus;
                    bonusBeforeTax += curBonusBeforeTax;
                }
                jCount = 0; //号码长度重新计算
                delete pNumType;
                if(j < length - 1)
                {
                    tmp = pChar + j + 1;
                }
            }
            else
            {
                jCount++;
            }
        }
        delete[] pChar;
    }
    rst->Set(String::NewSymbol("bonus"), Number::New(bonus));
    rst->Set(String::NewSymbol("bonusBeforeTax"), Number::New(bonusBeforeTax));
    rst->Set(String::NewSymbol("bonusDetail"), array);
    return scope.Close(rst);
}

/**
 * 组24，复式算奖
 */
Handle<Value> Check::Count0101(const Arguments& args)
{
    HandleScope scope;
    Check *self = ObjectWrap::Unwrap<Check>(args.This());
    Handle<Object> rst = Object::New();
    Handle<Array> array = Array::New();
    long bonus = 0;
    long bonusBeforeTax = 0;
    //号码类型是否相同
    if(self->pDrawNumType->getType() == NUM_TYPE_Z24)
    {
        //获得号码的字符串
        Local<Object> pObj = Local<Object>::Cast(args[0]);
        Local<String> pNum = pObj->Get(String::NewSymbol("number"))->ToString();
        int length = pNum->Utf8Length();
        char *pChar = new char[length];
        pNum->WriteUtf8(pChar);

        NumType *pNumType = new NumType(pChar, length);

        bool hit = true;    //是否中奖
        int drawLen = self->pDrawNumType->getCharLen();
        for(int i = 0; i < drawLen; i++)
        {
            char c = self->pDrawNumType->getCharAt(i);
            int iCount = self->pDrawNumType->getCharCountAt(i);
            if(pNumType->getCharCount(c) != iCount)
            {
                hit = false;
                break;
            }
        }
        if(hit)
        {
            long curBonus = self->gl->getBonus(0);
            long curBonusBeforeTax = self->gl->getBonus(0);
            Handle<Object> obj = Object::New();
            obj->Set(String::NewSymbol("bonus"), Number::New(curBonus));
            obj->Set(String::NewSymbol("bonusBeforeTax"), Number::New(curBonusBeforeTax));
            obj->Set(String::NewSymbol("level"), Number::New(1));
            obj->Set(String::NewSymbol("count"), Number::New(1));
            array->Set(array->Length(), obj);
            bonus += curBonus;
            bonusBeforeTax += curBonusBeforeTax;
        }

        delete pNumType;
        delete[] pChar;
    }
    rst->Set(String::NewSymbol("bonus"), Number::New(bonus));
    rst->Set(String::NewSymbol("bonusBeforeTax"), Number::New(bonusBeforeTax));
    rst->Set(String::NewSymbol("bonusDetail"), array);
    return scope.Close(rst);
}

/**
 * 组24，胆拖算奖
 */
Handle<Value> Check::Count0102(const Arguments& args)
{
    HandleScope scope;
    Check *self = ObjectWrap::Unwrap<Check>(args.This());
    Handle<Object> rst = Object::New();
    Handle<Array> array = Array::New();
    long bonus = 0;
    long bonusBeforeTax = 0;
    //号码类型是否相同
    if(self->pDrawNumType->getType() == NUM_TYPE_Z24)
    {
        //获得号码的字符串
        Local<Object> pObj = Local<Object>::Cast(args[0]);
        Local<String> pNum = pObj->Get(String::NewSymbol("number"))->ToString();
        int length = pNum->Utf8Length();
        char *pChar = new char[length];
        pNum->WriteUtf8(pChar);

        NumType *pDan, *pTuo;
        int pos = 0;
        for(int i = 0; i < length; i++)
        {
            char c = pChar[i];
            if(c == '$')
            {
                pos = i;
                break;
            }
        }
        char *pCharTuo = pChar + pos + 1;
        pDan = new NumType(pChar, pos);     //胆码
        pTuo = new NumType(pCharTuo, length - pos - 1); //拖码

        bool hit = true;    //是否中奖
        int danLen = pDan->getCharLen();
        for(int i = 0; i < danLen; i++)
        {
            char c = pDan->getCharAt(i);
            int iCount = self->pDrawNumType->getCharCount(c);
            if(iCount < 1)
            {
                hit = false;
                break;
            }
        }

        if(hit)
        {
            int tuoHitCount = 0;
            int tuoLen = pTuo->getCharLen();
            for(int i = 0; i < tuoLen; i++)
            {
                char c = pTuo->getCharAt(i);
                int iCount = self->pDrawNumType->getCharCount(c);
                if(iCount >= 1)
                {
                    tuoHitCount++;
                }
            }
            if(tuoHitCount + danLen < 4)    //总hit数必须大于等于4
            {
                hit = false;
            }
        }

        if(hit)
        {
            long curBonus = self->gl->getBonus(0);
            long curBonusBeforeTax = self->gl->getBonus(0);
            Handle<Object> obj = Object::New();
            obj->Set(String::NewSymbol("bonus"), Number::New(curBonus));
            obj->Set(String::NewSymbol("bonusBeforeTax"), Number::New(curBonusBeforeTax));
            obj->Set(String::NewSymbol("level"), Number::New(1));
            obj->Set(String::NewSymbol("count"), Number::New(1));
            array->Set(array->Length(), obj);
            bonus += curBonus;
            bonusBeforeTax += curBonusBeforeTax;
        }

        delete pDan;
        delete pTuo;
        delete[] pChar;
    }
    rst->Set(String::NewSymbol("bonus"), Number::New(bonus));
    rst->Set(String::NewSymbol("bonusBeforeTax"), Number::New(bonusBeforeTax));
    rst->Set(String::NewSymbol("bonusDetail"), array);
    return scope.Close(rst);
}


/**
 * Init方法中已经初始化过constructor变量，所以在这儿可以使用
 * constructor来新建一个对象。
 */
Handle<Value> Check::NewInstance(const Arguments& args)
{
    HandleScope scope;
    const unsigned argc = 0;
    Handle<Value> argv[argc] = {};
    Local<Object> instance = constructor->NewInstance(argc, argv);
    return scope.Close(instance);
}